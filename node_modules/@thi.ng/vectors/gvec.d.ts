import type { NumericArray } from "@thi.ng/api";
import type { IVector } from "./api.js";
/**
 * Wrapper for strided, arbitrary length vectors.
 *
 * @remarks
 * Wraps given buffer in ES6 `Proxy` with custom property getters/setters and
 * implements the following interfaces:
 *
 * - `Iterable` (ES6)
 * - [`ICopy`](https://docs.thi.ng/umbrella/api/interfaces/ICopy.html)
 * - [`IEmpty`](https://docs.thi.ng/umbrella/api/interfaces/IEmpty.html)
 * - [`IEqualsDelta`](https://docs.thi.ng/umbrella/api/interfaces/IEqualsDelta.html)
 * - {@link IVector}
 * - `Object.toString()`
 *
 * Read/write access for the following properties:
 *
 * - array indices in the `[0,size)` interval
 * - `offset` - start index
 * - `stride` - component stride
 * - `buf` - backing buffer (readonly)
 * - `length` - vector size
 *
 * Array index access uses bounds checking against the `[0,size)` interval, but,
 * for performance reasons, **not** against the actual wrapped buffer.
 *
 * Note: ES6 proxies are ~10x slower than standard array accesses. If several
 * computations are to be performed on such vectors it will be much more
 * efficient to first copy them to compact arrays and then copy result back if
 * needed.
 *
 * @example
 * ```ts tangle:../export/gvec.ts
 * import { gvec, add, copy, eqDelta } from "@thi.ng/vectors";
 *
 * // 3D vector w/ component stride length of 4
 * let a = gvec([1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], 3, 0, 4);
 *
 * console.log(a[0], a[1], a[2]);
 * // 1 2 3
 *
 * console.log(a.stride);
 * // 4
 *
 * console.log([...a]);
 * // [1, 2, 3]
 *
 * console.log(a.toString());
 * // "[1.000, 2.000, 3.000]"
 *
 * console.log(add([], a, a));
 * // [2, 4, 6]
 *
 * console.log(copy(a));
 * // [1, 2, 3]
 *
 * console.log(a.copyView());
 * // Proxy [ [ 1, 0, 2, 0, 3, 0 ], ... }
 *
 * console.log(eqDelta(a, [1, 2, 3]));
 * // true
 * ```
 *
 * @param buf - backing buffer
 * @param size - vector size / num components
 * @param offset - start index
 * @param stride - component stride
 */
export declare const gvec: (buf: NumericArray, size: number, offset?: number, stride?: number) => IVector<any>;
//# sourceMappingURL=gvec.d.ts.map