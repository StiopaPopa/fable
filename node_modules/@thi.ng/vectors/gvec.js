import { EPS } from "@thi.ng/math/api";
import { memoizeO } from "@thi.ng/memoize/memoizeo";
import { map } from "@thi.ng/transducers/map";
import { range } from "@thi.ng/transducers/range";
import { eqDeltaS } from "./eqdelta.js";
import { stridedValues } from "./iterator.js";
import { zeroes } from "./setn.js";
import { setS } from "./sets.js";
import { FORMATTER } from "./string.js";
const SYM_B = "buf";
const SYM_L = "length";
const SYM_O = "offset";
const SYM_S = "stride";
const SYM_C = "copy";
const SYM_CV = "copyView";
const SYM_EMPTY = "empty";
const SYM_EQD = "eqDelta";
const SYM_STR = "toString";
const PROPS = /* @__PURE__ */ new Set([
  SYM_B,
  SYM_C,
  SYM_CV,
  SYM_EMPTY,
  SYM_EQD,
  SYM_L,
  SYM_O,
  SYM_S,
  SYM_STR,
  Symbol.iterator
]);
const __keys = memoizeO((size) => [
  ...map(String, range(size)),
  ...PROPS
]);
const gvec = (buf, size, offset = 0, stride = 1) => new Proxy(buf, {
  get(obj, id) {
    switch (id) {
      case Symbol.iterator:
        return () => stridedValues(obj, size, offset, stride);
      case SYM_L:
        return size;
      case SYM_B:
        return buf;
      case SYM_O:
        return offset;
      case SYM_S:
        return stride;
      case SYM_C:
        return () => setS([], obj, size, 0, offset, 1, stride);
      case SYM_CV:
        return () => gvec(obj, size, offset, stride);
      case SYM_EMPTY:
        return () => zeroes(size);
      case SYM_EQD:
        return (o, eps = EPS) => eqDeltaS(buf, o, size, eps, offset, 0, stride, 1);
      case SYM_STR:
        return () => FORMATTER(stridedValues(obj, size, offset, stride));
      default:
        const j = parseInt(id);
        return !isNaN(j) && j >= 0 && j < size ? obj[offset + j * stride] : void 0;
    }
  },
  set(obj, id, value) {
    const j = parseInt(id);
    if (!isNaN(j) && j >= 0 && j < size) {
      obj[offset + (id | 0) * stride] = value;
    } else {
      switch (id) {
        case SYM_O:
          offset = value;
          break;
        case SYM_S:
          stride = value;
          break;
        case SYM_L:
          size = value;
          break;
        default:
          return false;
      }
    }
    return true;
  },
  has(_, id) {
    return id >= 0 && id < size || PROPS.has(id);
  },
  ownKeys() {
    return __keys(size);
  }
});
export {
  gvec
};
